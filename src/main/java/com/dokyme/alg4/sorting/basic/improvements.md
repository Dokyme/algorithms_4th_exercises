# 提高题

## 2.1.13 纸牌排序

把一副牌按照黑桃、红桃、梅花、方块的顺序排序。

0位置开始摆放黑桃，13开始拜访红桃，26开始摆放梅花，39开始拜访方块。使用四个指针记录四种花色的下一张牌应该存放的位置，从第一张牌开始翻，然后将其和应该存放的位置的牌进行交换，并移动对应花色指针，换回来的牌变成新的第一张，如此循环，直到四个指针都到位，说明所有的牌都已经按照花色排序到位。

但是我看题目的意思，好像不允许使用额外的指针记录位置。

于是还是借鉴插入排序的思路，使用一个额外的指针（这个应该是不可避免的了）记录已经排好序的序列。从0和1开始，如果后一张牌的花色大于前一张牌，就交换两张牌，否则继续取指针右侧的第一个元素和指针指向的元素进行比较。

## 2.1.14 出列排序

查看牌堆顶部的两张牌，将较小的牌换到牌堆顶部（也可能不需要交换），并移动牌堆顶部的牌到底部。一直这样重复，知道连续52次都没有发生交换，说明已经有序了，只是可能牌堆是循环有序的，需要手动换牌到最小的牌出现到顶部，此时整个排队从上到下才是递增的。

## 2.1.15 昂贵的交换

只有一个空位，需要尽量减少元素移动。基于这两个条件，应该选择选择排序。因为选择排序最坏的情况下也只需要交换N次元素。

## 2.1.16 验证

写倒是挺好写的。

```java_holder_method_tree
    public static boolean check(Comparable[] a) {
        Comparable[] backup = new Comparable[a.length];
        for (int i = 0; i < a.length; i++) {
            backup[i] = a[i];
        }
        sort(a);
        if (!compare(a, backup)) {
            return false;
        }
        Arrays.sort(backup);
        if (!compare(a, backup)) {
            return false;
        }
        return true;
    }
```

### 2.1.17 动画

