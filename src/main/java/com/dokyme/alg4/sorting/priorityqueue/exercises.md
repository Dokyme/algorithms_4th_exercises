# 练习

## 2.4.1 

```
R   R   P   O   T   Y   I   I   U   Q   E   U
```

## 2.4.2

我不懂题目里所说的用栈或者队列是怎么记录的，是保持栈顶的元素最大？

如果只要找到最大元素，那不用栈也不用队列，用一个变量就可以了。

## 2.4.3

实现了四种优先队列。

[DifferentPQ.java](https://github.com/Dokyme/algorithms_4th_exercises/blob/master/src/main/java/com/dokyme/alg4/sorting/priorityqueue/DifferentPQ.java)

实现 | insert | delMax 
- | :-: | -: 
有序数组 | n | 1 
无序数组 | 1 | n 
有序链表 | n | 1
无序链表 | 1 | n

## 2.4.4

降序排列的数组应该是一个最大堆，但最大堆不一定是降序排列数组。

## 2.4.5

```
Y   T   U   S   Q   N   E   A   S   I   O   E
```

## 2.4.6
```
P
P   R
P   R   I
P   R   I   O   
P   O   I
R   P   I   O
P   O   I
O   I   
O   I   I
I   I   
T   I   I
I   I
Y   I   I
I   I
I   

Q   
U   Q   
U   Q   E   
Q   E   
E   

U

E
```


## 2.4.7

一般的，在最大堆中，第k大的数据可能出现的位置为k/2+1,k/2+2,...,k+1

k=2时，第2大的数据可能出现在2,3

k=3时，第3大的数据可能出现在2,3

k=4时，第4大的数据可能出现在4,5,6,7

## 2.4.8

一般的，在最大堆中，第k小的数据可能出现的位置为

## 2.4.9

ABCDE五个元素可能构造出的所有（最大）堆：

首先E肯定是最大的，在堆顶，其次第二个元素肯定比4、5两个元素大，第3个元素不确定。

```
E   D   C   A   B
E   D   C   B   A
E   D   A   B   C
E   D   A   C   B
E   D   B   A   C
E   D   B   C   A
E   C   D   A   B
E   C   D   B   A
E   C   A   D   B
E   C   A   B   D
E   C   B   A   D
E   C   B   D   A
```

有点像全排列的问题，首先把堆顶元素定下来，然后依次填下所有元素中第2大的元素、第3大的元素，再填下第4大的元素，第5大的元素。。。

AAABB五个元素可能构造出的所有（最大）堆。堆顶肯定为B，另一个B肯定在第二层。

```
B   B   A   A   A
B   A   B   A   A
```

## 2.4.10

pq[k]的父节点为pq[k/2-1]，子节点为pq[2*k+1]和pq[2*k+2]。

## 2.4.11

无序数组实现的优先队列最为适用于存在大量插入元素操作且少量删除最大元素操作。

## 2.4.12

有序数组实现的优先队列最为适用于存在大量找出最大元素操作且少量改变数组结构的操作。

## 2.4.13

想要减少代码中的边界条件判断，一般是通过哨兵元素的最大最小性质实现。``sink()``函数中，``j<N``用于判断当前k节点是否存在两个子节点，如果有，则必然存在``j<N``，那么在下沉的过程中就需要判断两个子节点中哪个更大。

思考一下，有以下几种改进思路：

1. 调整堆的结构使得每个节点都有2个子节点。似乎有戏：让数组中除了（最大）堆之外的元素全部变为Integer.MIN_VALUE。
2. 调准循环控制条件，在``2*k+1>N``的时候退出循环，然后在循环外另外写条件。

我认为思路1是可行的。

## 2.4.14

至少要交换logN个元素。

**暂留**

## 2.4.15

只要判断每个元素都比他的父节点大就可以。

```
    public static <T extends Comparable> boolean test(MinHeap<T> minHeap) {
        T[] pq = minHeap.pq;
        for (int i = 2; i <= minHeap.n; i++) {
            if (Example.less(pq[i], pq[i / 2])) {
                return false;
            }
        }
        return true;
    }
```

## 2.4.16

堆排序的步骤主要分为两个部分，第一个部分是构造堆，第二个部分是每次都抽取最大的元素并移动到有序数组中去。

第一个部分比较元素事件产生于``sink()``操作中，要使``sink()``操作变多，只要起始时数组是顺序递增的数组。

第二个部分比较元素事件同样产生于``sink()``操作中，但在开始第二个阶段之前，堆已经成型，因此sink的次数可能不可控。

要使得比较次数最多，只要给出一个顺序递增的数组。要使得比较次数最少，只要给出一个顺序递减的数组。

## 2.4.17

**暂留**

## 2.4.18

不一定。

如：54321这个堆，插入6之后再删除6，得到的堆和原堆是不一样的。原因是1和数组最后一个元素的父节点不是同一个节点，导致6做swim操作的路径和1做sink操作的路径不同。6做swim操作的路径包含了其swim结束之后次大元素所在的新位置，而1做sink操作会沿着次大元素那一条路径走。

用一句话概括，插入6（swim）的路径和删除6（sink）的路径不一致。

据此作出推测，连续插入两次，再删除两次，得到的堆应该和原堆不一致。

## 2.4.19

```
    private void adjustHeap() {
        for (int i = n / 2; i > 0; i--) {
            sink(i);
        }
    }
```

## 2.4.20

假设数组长度为N-1。

一顿操作，我也不知道我算的对不对了。

![](https://github.com/Dokyme/algorithms_4th_exercises/blob/master/src/main/resources/2-4-20-1.png)